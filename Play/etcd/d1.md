# tasks
- Install etcd locally
- Explore etcdctl commands (put, get, del)
- Understand key-value basics, prefixes, and ranges
- Experiment with TTLs and key expiration
- Try JSON vs binary values

## etcdctl basics

```bash
# Put a value
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put demo/key "hello world"

# Get a value
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get demo/key

# Delete a value
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 del demo/key
```

## Key-value, prefixes, and ranges

etcd stores keys as byte sequences sorted lexicographically. Organize related data with path-like keys so prefix queries stay efficient.

```bash
# Seed namespaced keys
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put app/config/database postgres
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put app/config/cache redis
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put app/users/1001 '{"name":"Ada"}'
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put app/users/1002 '{"name":"Lin"}'
```

### Prefix scans

```bash
# Fetch everything under app/config/
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get app/config/ --prefix

# List only keys for users (no values)
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get app/users/ --prefix --keys-only
```

### Lexicographic range reads

```bash
# Get keys in the half-open range [app/config/, app/config0)
# Note: "0" is just after "/" in ASCII, limiting the range.
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get app/config/ app/config0

# Use ASCII successor helper to emulate prefix match without --prefix
succ=$(printf 'app/users/\x00')  # shell-escaped null byte marks the next possible key
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get app/users/ "$succ"
```

### Cleaning up

```bash
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 del --prefix app/
```

## TTLs and key expiration

Leases attach time-to-live semantics to keys. When the lease expires, every key bound to it disappears automatically.

```bash
# Grant a 15-second lease and capture its ID
lease_id=$(docker compose exec etcd etcdctl --endpoints=http://localhost:2379 lease grant 15 | awk '/lease / {print $3}')

# Store a session token bound to the lease
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put sessions/alice token-123 --lease="$lease_id"

# Inspect the lease metadata (remaning TTL, attached keys)
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 lease timetolive "$lease_id" --keys

# Read back the key before expiration
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get sessions/alice
```

### Keep leases alive

```bash
# Open a keep-alive stream from the host (Ctrl+C to stop refreshing)
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 lease keep-alive "$lease_id"
```

### Manual expiration check

```bash
# Wait for the lease to expire naturally if keep-alive is not running
sleep 20
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get sessions/alice
```

### Immediate revocation

```bash
# Force-remove keys by revoking the lease
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 lease revoke "$lease_id"

# Confirm the key is gone
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get sessions/alice
```

### Multiple keys, staggered leases

```bash
# Create a 5-second lease for short-lived sessions
short_lease=$(docker compose exec etcd etcdctl --endpoints=http://localhost:2379 lease grant 5 | awk '/lease / {print $3}')

# Create a 30-second lease for longer sessions
long_lease=$(docker compose exec etcd etcdctl --endpoints=http://localhost:2379 lease grant 30 | awk '/lease / {print $3}')

# Attach multiple keys to the same lease to expire together
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put sessions/bob token-456 --lease="$short_lease"
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put sessions/charlie token-789 --lease="$short_lease"

# Attach other keys to the longer lease
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put sessions/dana token-101 --lease="$long_lease"
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put sessions/erin token-202 --lease="$long_lease"

# Observe the shorter lease expiring keys together
sleep 6
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get sessions/ --prefix

# Revoke the longer lease to remove both keys at once
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 lease revoke "$long_lease"
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get sessions/ --prefix
```

## JSON vs binary values

etcd treats every value as an opaque byte array. Text formats like JSON are easy to inspect directly, while binary payloads benefit from helper flags.

### JSON payloads

```bash
# Store a JSON config document
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 put app/config/service '{"host":"api.internal","port":8080,"timeout_ms":1500}'

# Read it back raw
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get app/config/service --print-value-only

# Optionally pretty-print on the host if jq is installed
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get app/config/service --print-value-only | jq .
```

### Binary payloads

```bash
# Produce a non-text payload inside the container (0xCAFE BABE magic bytes)
docker compose exec etcd sh -c "printf '\312\376\272\276\001\002' > /tmp/blob.bin"

# Write the raw bytes to etcd (command substitution preserves the binary)
docker compose exec etcd sh -c "etcdctl --endpoints=http://localhost:2379 put blobs/raw \"$(cat /tmp/blob.bin)\""

# Inspect the stored bytes safely using --hex
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get blobs/raw --hex

# Fetch to the host for diffing/hexdump
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get blobs/raw --print-value-only > blobs_raw.bin
hexdump -C blobs_raw.bin
```

### Cleanup

```bash
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 del app/config/service
docker compose exec etcd etcdctl --endpoints=http://localhost:2379 del blobs/raw
rm -f blobs_raw.bin
```

## Bulk fake data loader

Use `scripts/load_fake_data.sh` to seed large batches. It defaults to 50 simple strings, 20 JSON documents, and 10 binary blobs under the `datasets/` prefix.

```bash
# Load data with defaults (requires the etcd container to be running)
./scripts/load_fake_data.sh

# Override counts or value sizes
STRING_COUNT=200 JSON_COUNT=80 BLOB_COUNT=20 BLOB_BYTES=64 ./scripts/load_fake_data.sh
```

Environment knobs: set `ETCD_ENDPOINT`, `COMPOSE_CMD`, or `ETCD_SERVICE` to target other deployments. Inspect the results with `docker compose exec etcd etcdctl --endpoints=http://localhost:2379 get datasets/ --prefix`.

## High-volume Go faker

Build the parallel writer that uses `gofakeit` to generate realistic payloads and push them straight into the cluster.

```bash
# Compile once (or use go run)
go build ./cmd/etcd-faker

# Load 100k keys with 64 workers against local compose endpoint
./etcd-faker -endpoints=localhost:2379 -n=100000 -c=64 -prefix=datasets/loadtest

# Target multiple endpoints or adjust payload mix
./etcd-faker -endpoints=localhost:2379,localhost:22379 -n=1000000 -c=128 -json=true -text=true -binary=false
```

Flags let you control concurrency, key counts, binary payload sizes, and randomness seeds. Check `./etcd-faker -h` for the full list. Pair runs with `etcdctl --prefix --keys-only get datasets/loadtest` or watch resource usage via `docker stats` to emulate production bursts.

## Reporting and stats

Compile the reporter to scan a prefix and summarize key counts, payload volume, and JSON price statistics.

```bash
go build ./cmd/etcd-reporter

# Inspect the default faker prefix
./etcd-reporter -endpoints=localhost:2379 -prefix=datasets/loadtest

# Tune batch size or switch to serializable reads if needed
./etcd-reporter -batch=5000 -serializable
```

The report groups keys by value type (text/json/binary/other), totals their byte footprints, and calculates average/min/max prices for JSON payloads that contain a `price` field. Use it after the faker runs to verify distribution and catch anomalies.
