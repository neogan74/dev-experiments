# Объяснение решения

Задача: посчитать количество разбиений массива на непустые подряд идущие сегменты так, чтобы в каждом сегменте `max - min <= k`. Ответ берём по модулю `1e9+7`.

## Идея
- Держим скользящее окно `[l, r]` и две монотонные очереди индексов для максимума и минимума в окне. Пока `max - min > k`, сдвигаем `l` и обновляем очереди.
- Пусть `dp[i]` — число способов разбить префикс `nums[:i]` (где `i` — количество элементов). Если текущее окно начинается с `l`, то последний сегмент для позиции `i` может начинаться в любом `j` из диапазона `[l, i-1]`. Тогда  
  `dp[i] = sum(dp[j])` для `j` в этом диапазоне.
- Чтобы суммировать быстро, храним префиксные суммы `pref[i] = dp[0] + ... + dp[i]`. Тогда  
  `dp[i] = pref[i-1] - pref[l-1]` (учитывая границу) за O(1).
- База: `dp[0] = 1` (пустой префикс) и `pref[0] = 1`.

## Почему это работает
Инварианты монотонных очередей дают корректные `max` и `min` для текущего окна. Минимально допустимое начало сегмента — `l`, иначе условие нарушается. Любое начало от `l` до `i-1` даёт валидный последний сегмент, а `dp[j]` учитывает все разбиения до `j`. Суммируя их, получаем все разбиения до `i`. Префиксные суммы делают этот подсчёт за O(1), поэтому рекурренция корректно строит ответ.

## Сложность
- Время O(n): каждый индекс заходит и выходит из очереди по разу, все операции — O(1) амортизированно.
- Память O(n) для `dp` и `pref`; очереди — O(n) в худшем случае, но по одному заходу/выходу на элемент.

## Пограничные случаи
- Все элементы равны: окно не сужается, сумма даёт все возможные разбиения.
- `k = 0`: окно сжимается при любом различии, считаем разбиения на блоки одинаковых чисел.
- Максимальные размеры входа: линейный алгоритм укладывается в ограничения.
